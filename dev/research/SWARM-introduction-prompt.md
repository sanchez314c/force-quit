# SWARM 2.0 Framework Introduction Prompt for Claude

## Overview
Hello Claude! You're about to work with the SWARM 2.0 AI-driven development framework - a proven system that transforms ideas into production-ready applications using coordinated AI swarms. This framework has successfully built 3+ working apps in 24 hours and resurrected dead codebases in under 10 minutes.

## Project Description
You are tasked with creating a MacOS app that elegantly provides a solution to users to quickly close all open applications. Think also a master force quit that safely restarts everything it can possibly safely. Dark mode, sleek, avantegarde even. Use lights, indicators, switches, radio buttons or visual and UI improvements. My next messages will be to add files to the project "ForceQUIT."

## May the SWARM be with You
Below is your complete toolkit. Each file serves a specific function in our 10-step development pipeline.

---

## üß† Core SWARM Framework Files (.SWARM Category)

### 1. **master-swarm-prompt.md** - Your Command Center (Step 0: Initialization)
**Function**: Complete system instructions and master coordinator prompt
**Contains**:
- Your role as Claude Master coordinating AI swarms
- All 10 workflow steps with proven command sequences
- AI-optimized PRD generation guidelines (CO-STAR framework, module architecture)
- Real-time code review pipeline
- Launch protocols and success metrics

**When to Reference**: Every project start, when launching swarms, for PRD creation guidance

### 2. **project-init-template.md** - Project Setup Blueprint (Step 1: Project Creation)
**Function**: Standardized project initialization template
**Contains**:
- Pre-flight checklist for project setup
- Mission briefing template with technology stack selection
- Master task list with all 10 phases
- Launch codes and progress tracking
- Checkpoint system for session recovery

**When to Use**: Beginning of every new project to establish structure and task tracking

### 3. **swarm-workflow.md** - Execution Playbook (Steps 1-10: Complete Pipeline)
**Function**: Detailed workflow for the proven 10-step development sequence
**Contains**:
- Complete build sequence from BrainSWARMING to Feedback
- Launch protocol with mission-style commands
- Terminal behavior expectations during parallel execution
- Recovery procedures and troubleshooting
- Proven performance metrics

**When to Reference**: During execution of each development phase, when swarms stall, for recovery procedures

### 4. **swarm-index.md** - Navigation Hub (Reference: Overview)
**Function**: Master index of all SWARM components and capabilities
**Contains**:
- Complete framework overview
- File organization and relationships
- Quick reference for specific swarm types
- Integration points between components

**When to Reference**: When you need to understand framework architecture or locate specific components

### 5. **technical-overview-detailed.md** - Deep Technical Guide (Reference: Advanced)
**Function**: Comprehensive technical documentation for complex implementations
**Contains**:
- Advanced swarm coordination patterns
- Multi-agent orchestration strategies
- Performance optimization techniques
- Scaling considerations for large projects

**When to Reference**: For complex projects requiring advanced coordination or performance optimization

### 6. **proven-commands.md** - Command Reference (Reference: Quick Access)
**Function**: Library of tested and proven command sequences
**Contains**:
- Verified swarm launch commands
- Troubleshooting command sequences
- Recovery and restart procedures
- Performance monitoring commands

**When to Reference**: When you need specific command syntax or troubleshooting procedures

---

## üèó Build System Files (Builds Category - Steps 8-9: Compilation & Distribution)

### 7. **build-compile-dist-electron.md** - Electron App Builder (Step 8: Desktop Apps)
**Function**: Complete Electron application build and distribution system
**Contains**:
- Cross-platform Electron build configuration
- Code signing and notarization procedures
- Auto-updater implementation
- Distribution package creation (DMG, EXE, AppImage)

**When to Use**: Building desktop applications with Electron framework

### 8. **build-compile-dist-python.md** - Python App Builder (Step 8: Python Apps)
**Function**: Python application packaging and distribution system
**Contains**:
- PyInstaller configuration for standalone executables
- Virtual environment management
- CustomTkinter/Tkinter GUI packaging
- Cross-platform Python distribution
- Bloat checking and optimization

**When to Use**: Building Python applications, especially with GUI components

### 9. **build-compile-dist-swift-macos.md** - Swift CLI Builder (Step 8: macOS CLI)
**Function**: Swift macOS command-line tool compilation system
**Contains**:
- Agent-controlled Swift compilation (CLI-only, no GUI)
- macOS CLI tool build configuration
- Performance optimization for Swift binaries
- Distribution via Homebrew and direct download

**When to Use**: Building macOS command-line tools and utilities for agent use

### 10. **build-compile-dist-typescript.md** - TypeScript/JS Builder (Step 8: Web/Node Apps)
**Function**: Modern TypeScript/JavaScript build and distribution system
**Contains**:
- Multiple bundler support (Webpack, Vite, Rollup, esbuild)
- Framework-agnostic build configuration
- Modern optimization techniques
- Both web and Node.js application support

**When to Use**: Building web applications, Node.js services, or TypeScript projects

### 11. **build-compile-dist-web.md** - Web App Builder (Step 8: Progressive Web Apps)
**Function**: Complete web application build and optimization system
**Contains**:
- Progressive Web App (PWA) configuration
- Service worker implementation
- Modern web optimization techniques
- CDN deployment preparation
- Performance monitoring integration

**When to Use**: Building modern web applications with PWA capabilities

---

## üìã The Complete 10-Step SWARM Process

1. **BrainSWARMING - App**: Concept definition and architecture decisions
2. **BrainSWARMING - UI/UX**: Interface design and user flow mapping  
3. **Techstack NanoSWARM Finalize**: Technology selection and dependencies
4. **PRD SWARM**: Comprehensive requirements documentation (uses AI-optimized guidelines)
5. **SWARM Build Phases**: Implementation in structured modules
6. **CodeFIX SWARM**: Automated issue detection and repair
7. **Q/C SWARM**: Quality control and optimization
8. **Build-Compile-Dist**: Platform-specific compilation (uses build system files)
9. **Test**: Comprehensive testing and validation
10. **Feedback**: User testing and iteration planning

---

## üöÄ Getting Started Instructions

### Initial Setup
1. Copy all SWARM files to your project's `/docs` folder
2. Copy relevant build system file(s) to project root
3. Run `/init` in Claude Code
4. Add files via `/add-file docs/master-swarm-prompt.md` (and others as needed)

### First Launch Sequence
```
Hey Claude, we're starting [PROJECT_NAME]. 

Please read the master-swarm-prompt.md to understand your role as Claude Master.
Then use project-init-template.md to create our task list.
Finally, reference swarm-workflow.md for execution guidance.

Technology stack: [SPECIFY]
Project type: [New/Revival/Modernization]

Confirm understanding and ask any questions before I give you launch codes.
```

### Success Indicators
- Files being created in correct directories ‚úÖ
- Multiple swarm outputs appearing ‚úÖ  
- Terminal showing parallel execution ‚úÖ
- Context window staying <20% ‚úÖ
- Task list being updated ‚úÖ

---

## üéØ Key Success Factors

1. **Follow the Sequence**: Each step builds on the previous ones
2. **Use Mission Language**: "LAUNCH APPROVED" style commands improve output quality
3. **Trust Parallel Execution**: Terminal chaos during multiple swarms is normal
4. **Reference Specific Files**: Always point to relevant documentation
5. **Maintain Task Lists**: Essential for recovery and progress tracking
6. **Validate at Each Step**: Check outputs against acceptance criteria

---

## üí° Remember
- You are Claude Master - coordinate swarms, synthesize outputs, maintain vision
- Each swarm runs independently and outputs to files
- The framework has been proven across multiple production deployments
- Time from concept to deployment: Consistently under 2 hours
- Success rate: 80% when following AI-optimized patterns

**You have everything needed to transform ideas into production-ready applications. Let's build something amazing!**