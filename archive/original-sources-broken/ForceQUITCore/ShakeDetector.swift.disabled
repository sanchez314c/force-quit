//
//  ShakeDetector.swift
//  ForceQUIT - Multi-Modal Activation System
//
//  Created by SWARM 2.0 AI Development Framework
//  Advanced device shake detection using Core Motion
//

import Foundation
import CoreMotion
import Combine

/// Advanced shake detection system using Core Motion accelerometer data
/// Provides customizable sensitivity and pattern recognition for device shake gestures
@MainActor
public final class ShakeDetector: ObservableObject {
    
    // MARK: - Published Properties
    @Published public private(set) var isShakeDetected = false
    @Published public private(set) var shakeIntensity: Double = 0.0
    @Published public private(set) var isMonitoring = false
    
    // MARK: - Configuration
    public struct Configuration {
        public var sensitivity: Double = 2.5 // Shake threshold
        public var minimumShakeDuration: TimeInterval = 0.3 // Minimum shake duration
        public var cooldownPeriod: TimeInterval = 1.0 // Cooldown between shake detections
        public var requiredShakeCount: Int = 2 // Number of shakes required
        public var samplingRate: TimeInterval = 0.02 // 50Hz sampling rate
        
        public init(
            sensitivity: Double = 2.5,
            minimumShakeDuration: TimeInterval = 0.3,
            cooldownPeriod: TimeInterval = 1.0,
            requiredShakeCount: Int = 2,
            samplingRate: TimeInterval = 0.02
        ) {
            self.sensitivity = sensitivity
            self.minimumShakeDuration = minimumShakeDuration
            self.cooldownPeriod = cooldownPeriod
            self.requiredShakeCount = requiredShakeCount
            self.samplingRate = samplingRate
        }
    }
    
    // MARK: - Private Properties
    private let motionManager = CMMotionManager()
    private var configuration: Configuration
    private var cancellables = Set<AnyCancellable>()
    private var shakeBuffer: [ShakeEvent] = []
    private var lastShakeTime: Date?
    private let operationQueue = OperationQueue()
    
    // MARK: - Shake Event Structure
    private struct ShakeEvent {
        let timestamp: Date
        let acceleration: CMAcceleration
        let magnitude: Double
        
        init(acceleration: CMAcceleration) {
            self.timestamp = Date()
            self.acceleration = acceleration
            self.magnitude = sqrt(pow(acceleration.x, 2) + pow(acceleration.y, 2) + pow(acceleration.z, 2))
        }
    }
    
    // MARK: - Publishers
    public let shakeDetectedPublisher = PassthroughSubject<ShakePattern, Never>()
    
    public enum ShakePattern {
        case singleShake(intensity: Double)
        case doubleShake(intensity: Double)
        case tripleShake(intensity: Double)
        case continuousShake(intensity: Double, duration: TimeInterval)
    }
    
    // MARK: - Initialization
    public init(configuration: Configuration = Configuration()) {
        self.configuration = configuration
        setupMotionManager()
    }
    
    deinit {
        stopMonitoring()
    }
    
    // MARK: - Public Methods
    
    /// Start monitoring device shake gestures
    public func startMonitoring() {
        guard !isMonitoring else { return }
        guard motionManager.isAccelerometerAvailable else {
            print("âš ï¸ ShakeDetector: Accelerometer not available")
            return
        }
        
        isMonitoring = true
        motionManager.accelerometerUpdateInterval = configuration.samplingRate
        
        motionManager.startAccelerometerUpdates(to: operationQueue) { [weak self] data, error in
            guard let self = self, let data = data else { return }
            
            Task { @MainActor in
                self.processAccelerometerData(data.acceleration)
            }
        }
        
        print("ðŸŽ¯ ShakeDetector: Started monitoring with sensitivity \(configuration.sensitivity)")
    }
    
    /// Stop monitoring device shake gestures
    public func stopMonitoring() {
        guard isMonitoring else { return }
        
        motionManager.stopAccelerometerUpdates()
        isMonitoring = false
        shakeBuffer.removeAll()
        isShakeDetected = false
        shakeIntensity = 0.0
        
        print("ðŸ”´ ShakeDetector: Stopped monitoring")
    }
    
    /// Update configuration settings
    public func updateConfiguration(_ newConfiguration: Configuration) {
        let wasMonitoring = isMonitoring
        if wasMonitoring {
            stopMonitoring()
        }
        
        configuration = newConfiguration
        
        if wasMonitoring {
            startMonitoring()
        }
        
        print("âš™ï¸ ShakeDetector: Configuration updated")
    }
    
    // MARK: - Private Methods
    
    private func setupMotionManager() {
        operationQueue.maxConcurrentOperationCount = 1
        operationQueue.qualityOfService = .userInteractive
    }
    
    private func processAccelerometerData(_ acceleration: CMAcceleration) {
        let event = ShakeEvent(acceleration: acceleration)
        
        // Update current intensity for UI feedback
        shakeIntensity = min(event.magnitude / configuration.sensitivity, 1.0)
        
        // Check if this qualifies as a shake
        if event.magnitude > configuration.sensitivity {
            addShakeEvent(event)
        }
        
        // Clean old events from buffer
        cleanShakeBuffer()
        
        // Analyze shake patterns
        analyzeShakePattern()
    }
    
    private func addShakeEvent(_ event: ShakeEvent) {
        shakeBuffer.append(event)
        
        // Limit buffer size for memory management
        if shakeBuffer.count > 100 {
            shakeBuffer.removeFirst(50)
        }
    }
    
    private func cleanShakeBuffer() {
        let cutoffTime = Date().timeIntervalSince1970 - (configuration.minimumShakeDuration * 3)
        shakeBuffer.removeAll { event in
            event.timestamp.timeIntervalSince1970 < cutoffTime
        }
    }
    
    private func analyzeShakePattern() {
        guard !shakeBuffer.isEmpty else { return }
        
        // Check cooldown period
        if let lastShake = lastShakeTime,
           Date().timeIntervalSince(lastShake) < configuration.cooldownPeriod {
            return
        }
        
        // Group shake events by proximity
        let recentEvents = getRecentShakeEvents()
        guard recentEvents.count >= configuration.requiredShakeCount else { return }
        
        // Detect shake patterns
        if let pattern = detectShakePattern(from: recentEvents) {
            handleShakeDetection(pattern)
        }
    }
    
    private func getRecentShakeEvents() -> [ShakeEvent] {
        let recentTimeWindow = Date().timeIntervalSince1970 - configuration.minimumShakeDuration
        return shakeBuffer.filter { event in
            event.timestamp.timeIntervalSince1970 > recentTimeWindow
        }
    }
    
    private func detectShakePattern(from events: [ShakeEvent]) -> ShakePattern? {
        guard !events.isEmpty else { return nil }
        
        let averageIntensity = events.map(\.magnitude).reduce(0, +) / Double(events.count)
        let duration = events.last!.timestamp.timeIntervalSince(events.first!.timestamp)
        
        // Classify shake pattern based on event count and duration
        switch events.count {
        case 2...4:
            return .doubleShake(intensity: averageIntensity)
        case 5...8:
            return .tripleShake(intensity: averageIntensity)
        case let count where count > 8 && duration > 0.8:
            return .continuousShake(intensity: averageIntensity, duration: duration)
        default:
            return .singleShake(intensity: averageIntensity)
        }
    }
    
    private func handleShakeDetection(_ pattern: ShakePattern) {
        lastShakeTime = Date()
        isShakeDetected = true
        
        // Publish shake event
        shakeDetectedPublisher.send(pattern)
        
        // Provide haptic feedback
        provideHapticFeedback(for: pattern)
        
        // Log detection
        logShakeDetection(pattern)
        
        // Reset shake detection after brief delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
            self?.isShakeDetected = false
        }
    }
    
    private func provideHapticFeedback(for pattern: ShakePattern) {
        // Note: Haptic feedback on macOS is limited, but we can prepare for future support
        print("ðŸ”„ ShakeDetector: Haptic feedback for pattern: \(pattern)")
    }
    
    private func logShakeDetection(_ pattern: ShakePattern) {
        let patternDescription: String
        switch pattern {
        case .singleShake(let intensity):
            patternDescription = "Single shake (intensity: \(String(format: "%.2f", intensity)))"
        case .doubleShake(let intensity):
            patternDescription = "Double shake (intensity: \(String(format: "%.2f", intensity)))"
        case .tripleShake(let intensity):
            patternDescription = "Triple shake (intensity: \(String(format: "%.2f", intensity)))"
        case .continuousShake(let intensity, let duration):
            patternDescription = "Continuous shake (intensity: \(String(format: "%.2f", intensity)), duration: \(String(format: "%.2f", duration))s)"
        }
        
        print("ðŸŽ¯ ShakeDetector: Detected \(patternDescription)")
    }
}

// MARK: - ShakeDetector Extensions

extension ShakeDetector {
    
    /// Convenience method to detect any shake pattern
    public func onAnyShake(_ handler: @escaping (ShakePattern) -> Void) {
        shakeDetectedPublisher
            .sink { pattern in
                handler(pattern)
            }
            .store(in: &cancellables)
    }
    
    /// Convenience method to detect specific shake patterns
    public func onShakePattern<T>(_ patternType: T.Type, handler: @escaping (T) -> Void) where T: Equatable {
        shakeDetectedPublisher
            .compactMap { pattern -> T? in
                pattern as? T
            }
            .sink { pattern in
                handler(pattern)
            }
            .store(in: &cancellables)
    }
    
    /// Get current shake detector status
    public var status: String {
        if isMonitoring {
            return isShakeDetected ? "ðŸŽ¯ Shake Detected!" : "ðŸ‘€ Monitoring..."
        } else {
            return "ðŸ’¤ Inactive"
        }
    }
}