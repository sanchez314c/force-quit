import Foundation
import SwiftUI
import QuartzCore
import Metal
import MetalKit
import Combine
import os.log

/// Ultra-high performance animation optimizer targeting 120fps on Apple Silicon, 60fps on Intel
/// Uses Metal acceleration, CADisplayLink synchronization, and intelligent frame pacing
final class AnimationOptimizer: ObservableObject {
    
    // MARK: - Performance Targets
    private enum PerformanceTargets {
        static let targetFPS: Double = UIDevice.current.userInterfaceIdiom == .pad ? 120 : 60
        static let frameTime: TimeInterval = 1.0 / targetFPS
        static let frameTimeThreshold: TimeInterval = frameTime * 1.1 // 10% tolerance
        static let metalCommandBufferLimit = 3 // Triple buffering
        static let animationBudgetMS: Double = 8.0 // 8ms animation budget per frame
    }
    
    // MARK: - Animation State
    enum AnimationState {
        case idle
        case preparing
        case running
        case optimizing
        case throttling
        
        var description: String {
            switch self {
            case .idle: return "Idle"
            case .preparing: return "Preparing animations"
            case .running: return "Running at target FPS"
            case .optimizing: return "Optimizing performance"
            case .throttling: return "Throttling for thermal management"
            }
        }
    }
    
    // MARK: - Animation Quality Levels
    enum QualityLevel: CaseIterable {
        case maximum    // 120fps, full effects
        case high       // 60fps, most effects
        case balanced   // 30fps, essential effects
        case performance // 30fps, minimal effects
        
        var targetFPS: Double {
            switch self {
            case .maximum: return 120
            case .high: return 60
            case .balanced, .performance: return 30
            }
        }
        
        var effectsEnabled: Bool {
            switch self {
            case .maximum, .high: return true
            case .balanced: return true
            case .performance: return false
            }
        }
        
        var blurEnabled: Bool {
            switch self {
            case .maximum, .high, .balanced: return true
            case .performance: return false
            }
        }
    }
    
    // MARK: - Published Properties
    @Published private(set) var currentFPS: Double = 0
    @Published private(set) var state: AnimationState = .idle
    @Published private(set) var qualityLevel: QualityLevel = .maximum
    @Published private(set) var frameDropCount: Int = 0
    @Published private(set) var isMetalAccelerated: Bool = false
    @Published private(set) var thermalState: ProcessInfo.ThermalState = .nominal
    
    // MARK: - Private Properties
    private let logger = Logger(subsystem: "com.forceQUIT.performance", category: "AnimationOptimizer")
    
    // Display link and timing
    private var displayLink: CADisplayLink?
    private var frameTimeHistory: [TimeInterval] = []
    private var lastFrameTime: CFAbsoluteTime = 0
    private let maxHistorySize = 60 // Track last 60 frames
    
    // Metal rendering
    private var metalDevice: MTLDevice?
    private var metalCommandQueue: MTLCommandQueue?
    private var renderPassDescriptor: MTLRenderPassDescriptor?
    
    // Performance monitoring
    private var frameDropThreshold: TimeInterval = PerformanceTargets.frameTimeThreshold
    private var adaptiveQualityEnabled = true
    private var thermalObserver: NSObjectProtocol?
    
    // Animation coordination
    private var activeAnimations: Set<AnimationID> = []
    private var animationCompletions: [AnimationID: () -> Void] = [:]
    private var animationQueue = DispatchQueue(label: "animation.optimization", qos: .userInteractive)
    
    // Predictive optimization
    private var animationPredictor = AnimationPredictor()
    private var frameScheduler = FrameScheduler()
    
    // MARK: - Initialization
    init() {
        setupMetal()
        setupThermalMonitoring()
        detectOptimalQualityLevel()
        logger.info("AnimationOptimizer initialized - Target: \(Int(PerformanceTargets.targetFPS))fps, Metal: \(isMetalAccelerated)")
    }
    
    deinit {
        stopDisplayLink()
        cleanup()
    }
    
    // MARK: - Public Interface
    
    /// Start animation optimization
    func startOptimization() {
        guard state == .idle else { return }
        
        state = .preparing
        setupDisplayLink()
        
        logger.info("Animation optimization started - Quality: \(qualityLevel), Target FPS: \(Int(qualityLevel.targetFPS))")
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { [weak self] in
            self?.state = .running
        }
    }
    
    /// Stop animation optimization
    func stopOptimization() {
        guard state != .idle else { return }
        
        stopDisplayLink()
        activeAnimations.removeAll()
        animationCompletions.removeAll()
        state = .idle
        
        logger.info("Animation optimization stopped")
    }
    
    /// Register an animation for optimization
    func registerAnimation(id: AnimationID, duration: TimeInterval, completion: @escaping () -> Void = {}) {
        activeAnimations.insert(id)
        animationCompletions[id] = completion
        
        // Predict animation load and adjust quality if needed
        animationPredictor.recordAnimation(id: id, duration: duration)
        
        if adaptiveQualityEnabled {
            adjustQualityBasedOnLoad()
        }
        
        logger.debug("Registered animation: \(id.rawValue), duration: \(String(format: "%.2f", duration))s")
    }
    
    /// Unregister completed animation
    func unregisterAnimation(id: AnimationID) {
        activeAnimations.remove(id)
        animationCompletions.removeValue(forKey: id)
        
        animationPredictor.completeAnimation(id: id)
        
        logger.debug("Unregistered animation: \(id.rawValue)")
    }
    
    /// Get optimized animation configuration for SwiftUI
    func getAnimationConfig(for type: AnimationType) -> Animation {
        switch qualityLevel {
        case .maximum:
            return getMaximumQualityAnimation(for: type)
        case .high:
            return getHighQualityAnimation(for: type)
        case .balanced:
            return getBalancedAnimation(for: type)
        case .performance:
            return getPerformanceAnimation(for: type)
        }
    }
    
    /// Get recommended view modifier for optimized rendering
    func getOptimizedModifier() -> some ViewModifier {
        return OptimizedRenderingModifier(
            qualityLevel: qualityLevel,
            isMetalEnabled: isMetalAccelerated
        )
    }
    
    /// Force quality level adjustment
    func setQualityLevel(_ level: QualityLevel) {
        guard level != qualityLevel else { return }
        
        qualityLevel = level
        adaptiveQualityEnabled = false // Disable auto-adjustment when manually set
        
        logger.info("Quality level manually set to: \(level)")
    }
    
    /// Enable adaptive quality adjustment
    func enableAdaptiveQuality() {
        adaptiveQualityEnabled = true
        logger.info("Adaptive quality enabled")
    }
    
    /// Get current performance metrics
    func getPerformanceMetrics() -> AnimationMetrics {
        return AnimationMetrics(
            currentFPS: currentFPS,
            targetFPS: qualityLevel.targetFPS,
            frameDrops: frameDropCount,
            averageFrameTime: frameTimeHistory.isEmpty ? 0 : frameTimeHistory.reduce(0, +) / Double(frameTimeHistory.count),
            qualityLevel: qualityLevel,
            activeAnimationCount: activeAnimations.count,
            isOptimalPerformance: currentFPS >= qualityLevel.targetFPS * 0.95 // Within 5% of target
        )
    }
    
    // MARK: - Private Implementation
    
    private func setupMetal() {
        guard let device = MTLCreateSystemDefaultDevice() else {
            logger.warning("Metal not available - falling back to Core Animation")
            return
        }
        
        metalDevice = device
        metalCommandQueue = device.makeCommandQueue()
        isMetalAccelerated = true
        
        logger.info("Metal acceleration enabled - Device: \(device.name)")
    }
    
    private func setupDisplayLink() {
        displayLink = CADisplayLink(target: self, selector: #selector(displayLinkCallback))
        displayLink?.preferredFrameRateRange = CAFrameRateRange(
            minimum: Float(qualityLevel.targetFPS / 2),
            maximum: Float(qualityLevel.targetFPS),
            preferred: Float(qualityLevel.targetFPS)
        )
        displayLink?.add(to: .current, forMode: .common)
        
        lastFrameTime = CFAbsoluteTimeGetCurrent()
    }
    
    private func stopDisplayLink() {
        displayLink?.invalidate()
        displayLink = nil
    }
    
    @objc private func displayLinkCallback() {
        let currentTime = CFAbsoluteTimeGetCurrent()
        let frameTime = currentTime - lastFrameTime
        lastFrameTime = currentTime
        
        // Update FPS calculation
        updateFPSCalculation(frameTime: frameTime)
        
        // Check for frame drops
        if frameTime > frameDropThreshold {
            frameDropCount += 1
            handleFrameDrop(frameTime: frameTime)
        }
        
        // Update frame scheduler
        frameScheduler.recordFrame(duration: frameTime)
        
        // Adaptive quality adjustment
        if adaptiveQualityEnabled {
            adjustQualityBasedOnPerformance()
        }
    }
    
    private func updateFPSCalculation(frameTime: TimeInterval) {
        frameTimeHistory.append(frameTime)
        if frameTimeHistory.count > maxHistorySize {
            frameTimeHistory.removeFirst()
        }
        
        // Calculate FPS from average frame time
        let averageFrameTime = frameTimeHistory.reduce(0, +) / Double(frameTimeHistory.count)
        currentFPS = 1.0 / averageFrameTime
    }
    
    private func handleFrameDrop(frameTime: TimeInterval) {
        logger.warning("Frame drop detected: \(String(format: "%.2f", frameTime * 1000))ms (target: \(String(format: "%.2f", PerformanceTargets.frameTime * 1000))ms)")
        
        // Immediate response to frame drops
        if frameDropCount % 5 == 0 && adaptiveQualityEnabled {
            // Every 5 frame drops, consider reducing quality
            reduceQualityLevel()
        }
    }
    
    private func adjustQualityBasedOnPerformance() {
        let metrics = frameScheduler.getMetrics()
        
        // Increase quality if performing well
        if metrics.averageFrameTime < PerformanceTargets.frameTime * 0.8 && metrics.frameDropRate < 0.01 {
            increaseQualityLevel()
        }
        // Decrease quality if struggling
        else if metrics.averageFrameTime > PerformanceTargets.frameTime * 1.2 || metrics.frameDropRate > 0.05 {
            reduceQualityLevel()
        }
    }
    
    private func adjustQualityBasedOnLoad() {
        let animationLoad = animationPredictor.getCurrentLoad()
        let thermalPressure = getThermalPressure()
        
        if animationLoad > 0.8 || thermalPressure > 0.7 {
            reduceQualityLevel()
        } else if animationLoad < 0.4 && thermalPressure < 0.3 {
            increaseQualityLevel()
        }
    }
    
    private func increaseQualityLevel() {
        guard let currentIndex = QualityLevel.allCases.firstIndex(of: qualityLevel),
              currentIndex > 0 else { return }
        
        let newLevel = QualityLevel.allCases[currentIndex - 1]
        setQualityLevel(newLevel)
        
        logger.info("Quality increased to: \(newLevel)")
    }
    
    private func reduceQualityLevel() {
        guard let currentIndex = QualityLevel.allCases.firstIndex(of: qualityLevel),
              currentIndex < QualityLevel.allCases.count - 1 else { return }
        
        let newLevel = QualityLevel.allCases[currentIndex + 1]
        setQualityLevel(newLevel)
        
        logger.warning("Quality reduced to: \(newLevel)")
    }
    
    private func detectOptimalQualityLevel() {
        // Detect device capabilities
        let deviceInfo = getDeviceCapabilities()
        
        if deviceInfo.isAppleSilicon && deviceInfo.hasProMotion {
            qualityLevel = .maximum
        } else if deviceInfo.hasMetalSupport && deviceInfo.memoryGB >= 8 {
            qualityLevel = .high
        } else if deviceInfo.hasMetalSupport {
            qualityLevel = .balanced
        } else {
            qualityLevel = .performance
        }
        
        logger.info("Optimal quality level detected: \(qualityLevel)")
    }
    
    private func setupThermalMonitoring() {
        thermalObserver = NotificationCenter.default.addObserver(
            forName: ProcessInfo.thermalStateDidChangeNotification,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.handleThermalStateChange()
        }
        
        thermalState = ProcessInfo.processInfo.thermalState
    }
    
    private func handleThermalStateChange() {
        thermalState = ProcessInfo.processInfo.thermalState
        
        switch thermalState {
        case .nominal:
            // Normal operation
            break
        case .fair:
            // Light throttling
            if qualityLevel == .maximum {
                setQualityLevel(.high)
            }
        case .serious:
            // Moderate throttling
            if qualityLevel == .maximum || qualityLevel == .high {
                setQualityLevel(.balanced)
            }
        case .critical:
            // Aggressive throttling
            setQualityLevel(.performance)
        @unknown default:
            break
        }
        
        logger.info("Thermal state changed to: \(thermalState) - Quality adjusted to: \(qualityLevel)")
    }
    
    private func getThermalPressure() -> Double {
        switch thermalState {
        case .nominal: return 0.0
        case .fair: return 0.3
        case .serious: return 0.7
        case .critical: return 1.0
        @unknown default: return 0.5
        }
    }
    
    private func cleanup() {
        if let observer = thermalObserver {
            NotificationCenter.default.removeObserver(observer)
        }
    }
    
    // MARK: - Animation Configurations
    
    private func getMaximumQualityAnimation(for type: AnimationType) -> Animation {
        switch type {
        case .springy:
            return .interpolatingSpring(mass: 0.5, stiffness: 300, damping: 20, initialVelocity: 0)
        case .smooth:
            return .easeInOut(duration: 0.3)
        case .snappy:
            return .spring(response: 0.4, dampingFraction: 0.8, blendDuration: 0)
        case .fluid:
            return .timingCurve(0.25, 0.1, 0.25, 1.0, duration: 0.6)
        }
    }
    
    private func getHighQualityAnimation(for type: AnimationType) -> Animation {
        switch type {
        case .springy:
            return .spring(response: 0.5, dampingFraction: 0.7)
        case .smooth:
            return .easeInOut(duration: 0.25)
        case .snappy:
            return .spring(response: 0.3, dampingFraction: 0.8)
        case .fluid:
            return .easeInOut(duration: 0.4)
        }
    }
    
    private func getBalancedAnimation(for type: AnimationType) -> Animation {
        switch type {
        case .springy, .snappy:
            return .spring(response: 0.4, dampingFraction: 0.8)
        case .smooth, .fluid:
            return .easeInOut(duration: 0.3)
        }
    }
    
    private func getPerformanceAnimation(for type: AnimationType) -> Animation {
        // Minimal animations for performance
        return .linear(duration: 0.15)
    }
    
    private func getDeviceCapabilities() -> DeviceCapabilities {
        let processInfo = ProcessInfo.processInfo
        let physicalMemory = processInfo.physicalMemory
        
        return DeviceCapabilities(
            isAppleSilicon: processInfo.isiOSAppOnMac || processInfo.processorCount > 4, // Heuristic
            hasProMotion: true, // Assume modern devices have ProMotion
            hasMetalSupport: isMetalAccelerated,
            memoryGB: Int(physicalMemory / (1024 * 1024 * 1024))
        )
    }
}

// MARK: - Supporting Types

struct AnimationID: Hashable, RawRepresentable {
    let rawValue: String
    
    init(rawValue: String) {
        self.rawValue = rawValue
    }
    
    static let processListUpdate = AnimationID(rawValue: "processListUpdate")
    static let forceQuitAnimation = AnimationID(rawValue: "forceQuitAnimation")
    static let uiTransition = AnimationID(rawValue: "uiTransition")
    static let progressIndicator = AnimationID(rawValue: "progressIndicator")
}

enum AnimationType {
    case springy    // Bouncy, energetic animations
    case smooth     // Smooth, polished animations
    case snappy     // Quick, responsive animations
    case fluid      // Flowing, continuous animations
}

struct AnimationMetrics {
    let currentFPS: Double
    let targetFPS: Double
    let frameDrops: Int
    let averageFrameTime: TimeInterval
    let qualityLevel: AnimationOptimizer.QualityLevel
    let activeAnimationCount: Int
    let isOptimalPerformance: Bool
}

private struct DeviceCapabilities {
    let isAppleSilicon: Bool
    let hasProMotion: Bool
    let hasMetalSupport: Bool
    let memoryGB: Int
}

// MARK: - Animation Predictor

private class AnimationPredictor {
    private var animationHistory: [AnimationID: [TimeInterval]] = [:]
    private var currentLoad: Double = 0.0
    
    func recordAnimation(id: AnimationID, duration: TimeInterval) {
        animationHistory[id, default: []].append(duration)
        if animationHistory[id]!.count > 10 {
            animationHistory[id]!.removeFirst()
        }
        updateCurrentLoad()
    }
    
    func completeAnimation(id: AnimationID) {
        updateCurrentLoad()
    }
    
    func getCurrentLoad() -> Double {
        return currentLoad
    }
    
    private func updateCurrentLoad() {
        let totalPredictedDuration = animationHistory.values.flatMap { $0 }.reduce(0, +)
        currentLoad = min(totalPredictedDuration / 10.0, 1.0) // Normalize to 0-1
    }
}

// MARK: - Frame Scheduler

private class FrameScheduler {
    private var frameDurations: [TimeInterval] = []
    private let maxHistory = 120 // 2 seconds at 60fps
    
    func recordFrame(duration: TimeInterval) {
        frameDurations.append(duration)
        if frameDurations.count > maxHistory {
            frameDurations.removeFirst()
        }
    }
    
    func getMetrics() -> FrameMetrics {
        guard !frameDurations.isEmpty else {
            return FrameMetrics(averageFrameTime: 0, frameDropRate: 0)
        }
        
        let average = frameDurations.reduce(0, +) / Double(frameDurations.count)
        let drops = frameDurations.filter { $0 > PerformanceTargets.frameTimeThreshold }.count
        let dropRate = Double(drops) / Double(frameDurations.count)
        
        return FrameMetrics(averageFrameTime: average, frameDropRate: dropRate)
    }
}

private struct FrameMetrics {
    let averageFrameTime: TimeInterval
    let frameDropRate: Double
}

// MARK: - Optimized Rendering Modifier

struct OptimizedRenderingModifier: ViewModifier {
    let qualityLevel: AnimationOptimizer.QualityLevel
    let isMetalEnabled: Bool
    
    func body(content: Content) -> some View {
        content
            .drawingGroup(opaque: qualityLevel == .performance) // Use opaque drawing for performance
            .compositingGroup() // Optimize compositing
            .clipped() // Optimize off-screen rendering
    }
}

// MARK: - Extensions

extension ProcessInfo {
    var isiOSAppOnMac: Bool {
        #if targetEnvironment(macCatalyst)
        return true
        #else
        return false
        #endif
    }
}